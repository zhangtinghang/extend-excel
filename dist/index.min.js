import * as e from 'xlsx'
import t from 'file-saver'
import { chain as o, cloneDeep as r } from 'lodash'
var a = {
  importExcel: (t, o = { onlyFirst: !1, XLSXReadOptions: {} }) => {
    const { onlyFirst: r, XLSXReadOptions: a } = o,
      s = t.name,
      n = new FileReader()
    return (
      n.readAsBinaryString(t),
      new Promise((t, o) => {
        n.onload = (n) => {
          try {
            const o = n.target?.result,
              l = e.read(o, { type: 'binary', ...a })
            let p = []
            for (var i in l.Sheets)
              if (
                l.Sheets.hasOwnProperty(i) &&
                ((p = p.concat(e.utils.sheet_to_json(l.Sheets[i]))), r)
              )
                break
            t({ name: s, data: p })
          } catch (e) {
            o(e)
          }
        }
      })
    )
  },
  exportExcel: (
    a,
    s,
    n = { fileName: 'export', sheetName: 'sheet1', XLSXOption: {} }
  ) => {
    const { fileName: i, sheetName: l, XLSXOption: p } = n
    if (!s || !Array.isArray(s))
      throw new Error('The sourceData needs to be in array format!')
    const c = o(s)
        .map((e) => {
          const t = r(e)
          return Object.keys(t).reduce((e, o) => {
            if (a[o])
              if (a[o] && 'object' == typeof a[o]) {
                const r = a[o].key,
                  s = a[o].filter(t[o])
                e[r] = s
              } else e[a[o]] = t[o]
            return e
          }, {})
        })
        .value(),
      m = e.utils.book_new(),
      y = e.utils.json_to_sheet(c)
    e.utils.book_append_sheet(m, y, l)
    const f = { bookType: 'xlsx', bookSST: !1, type: 'array', ...p },
      h = e.write(m, f)
    t.saveAs(new Blob([h], { type: 'application/octet-stream' }), `${i}.xlsx`)
  }
}
export { a as default }
